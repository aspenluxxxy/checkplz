diff --git i/common/socket.c w/common/socket.c
index fd89c56..4702c80 100644
--- i/common/socket.c
+++ w/common/socket.c
@@ -43,10 +43,6 @@ static int wsa_init = 0;
 #include <netdb.h>
 #include <arpa/inet.h>
 #include <fcntl.h>
-#ifdef AF_INET6
-#include <net/if.h>
-#include <ifaddrs.h>
-#endif
 #endif
 #include "socket.h"
 
@@ -87,11 +83,6 @@ const char *socket_addr_to_string(struct sockaddr *addr, char *addr_out, size_t
 	if (addr->sa_family == AF_INET) {
 		addrlen = sizeof(struct sockaddr_in);
 	}
-#ifdef AF_INET6
-	else if (addr->sa_family == AF_INET6) {
-		addrlen = sizeof(struct sockaddr_in6);
-	}
-#endif
 	else {
 		errno = EAFNOSUPPORT;
 		return NULL;
@@ -106,11 +97,6 @@ const char *socket_addr_to_string(struct sockaddr *addr, char *addr_out, size_t
 	if (addr->sa_family == AF_INET) {
 		addrdata = &((struct sockaddr_in*)addr)->sin_addr;
 	}
-#ifdef AF_INET6
-	else if (addr->sa_family == AF_INET6) {
-		addrdata = &((struct sockaddr_in6*)addr)->sin6_addr;
-	}
-#endif
 	else {
 		errno = EAFNOSUPPORT;
 		return NULL;
@@ -287,7 +273,7 @@ int socket_create(const char* addr, uint16_t port)
 	sprintf(portstr, "%d", port);
 
 	if (!addr) {
-		addr = "localhost";
+		addr = "127.0.0.1";
 	}
 	res = getaddrinfo(addr, portstr, &hints, &result);
 	if (res != 0) {
@@ -315,14 +301,6 @@ int socket_create(const char* addr, uint16_t port)
 		}
 #endif
 
-#if defined(AF_INET6) && defined(IPV6_V6ONLY)
-		if (rp->ai_family == AF_INET6) {
-			if (setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (void*)&yes, sizeof(int)) == -1) {
-				perror("setsockopt() IPV6_V6ONLY");
-			}
-		}
-#endif
-
 		if (bind(sfd, rp->ai_addr, rp->ai_addrlen) < 0) {
 			perror("bind()");
 			socket_close(sfd);
@@ -346,125 +324,6 @@ int socket_create(const char* addr, uint16_t port)
 	return sfd;
 }
 
-#ifdef AF_INET6
-static uint32_t _in6_addr_scope(struct in6_addr* addr)
-{
-	uint32_t scope = 0;
-
-	if (IN6_IS_ADDR_MULTICAST(addr)) {
-		if (IN6_IS_ADDR_MC_NODELOCAL(addr)) {
-			scope = 1;
-		} else if (IN6_IS_ADDR_MC_LINKLOCAL(addr)) {
-			scope = 2;
-		} else if (IN6_IS_ADDR_MC_SITELOCAL(addr)) {
-			scope = 5;
-		}
-
-		return scope;
-	}
-
-	if (IN6_IS_ADDR_LINKLOCAL(addr)) {
-		scope = 2;
-	} else if (IN6_IS_ADDR_LOOPBACK(addr)) {
-		scope = 2;
-	} else if (IN6_IS_ADDR_SITELOCAL(addr)) {
-		scope = 5;
-	} else if (IN6_IS_ADDR_UNSPECIFIED(addr)) {
-		scope = 0;
-	}
-
-	return scope;
-}
-
-static int32_t _sockaddr_in6_scope_id(struct sockaddr_in6* addr)
-{
-	int32_t res = -1;
-	struct ifaddrs *ifaddr, *ifa;
-	uint32_t addr_scope;
-
-	/* get scope for requested address */
-	addr_scope = _in6_addr_scope(&addr->sin6_addr);
-	if (addr_scope == 0) {
-		/* global scope doesn't need a specific scope id */
-		return addr_scope;
-	}
-
-	/* get interfaces */
-	if (getifaddrs(&ifaddr) == -1) {
-		perror("getifaddrs");
-		return res;
-	}
-
-	/* loop over interfaces */
-	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
-		/* skip if no address is available */
-		if (ifa->ifa_addr == NULL) {
-			continue;
-		}
-
-		/* skip if wrong family */
-		if (ifa->ifa_addr->sa_family != AF_INET6) {
-			continue;
-		}
-
-		/* skip if not up */
-		if ((ifa->ifa_flags & IFF_UP) == 0) {
-			continue;
-		}
-
-		/* skip if not running */
-		if ((ifa->ifa_flags & IFF_RUNNING) == 0) {
-			continue;
-		}
-
-		struct sockaddr_in6* addr_in = (struct sockaddr_in6*)ifa->ifa_addr;
-
-		/* skip if scopes do not match */
-		if (_in6_addr_scope(&addr_in->sin6_addr) != addr_scope) {
-			continue;
-		}
-
-		/* use if address is equal */
-		if (memcmp(&addr->sin6_addr.s6_addr, &addr_in->sin6_addr.s6_addr, sizeof(addr_in->sin6_addr.s6_addr)) == 0) {
-			/* if scope id equals the requested one then assume it was valid */
-			if (addr->sin6_scope_id == addr_in->sin6_scope_id) {
-				res = addr_in->sin6_scope_id;
-				break;
-			} else {
-				if ((addr_in->sin6_scope_id > addr->sin6_scope_id) && (res >= 0)) {
-					// use last valid scope id as we're past the requested scope id
-					break;
-				}
-				res = addr_in->sin6_scope_id;
-				continue;
-			}
-		}
-
-		/* skip loopback interface if not already matched exactly above */
-		if ((ifa->ifa_flags & IFF_LOOPBACK) != 0) {
-			continue;
-		}
-
-		if ((addr_in->sin6_scope_id > addr->sin6_scope_id) && (res >= 0)) {
-			// use last valid scope id as we're past the requested scope id
-			break;
-		}
-
-		res = addr_in->sin6_scope_id;
-
-		/* if scope id equals the requested one then assume it was valid */
-		if (addr->sin6_scope_id == addr_in->sin6_scope_id) {
-			/* set the scope id of this interface as most likely candidate */
-			break;
-		}
-	}
-
-	freeifaddrs(ifaddr);
-
-	return res;
-}
-#endif
-
 int socket_connect_addr(struct sockaddr* addr, uint16_t port)
 {
 	int sfd = -1;
@@ -488,25 +347,6 @@ int socket_connect_addr(struct sockaddr* addr, uint16_t port)
 		addr_in->sin_port = htons(port);
 		addrlen = sizeof(struct sockaddr_in);
 	}
-#ifdef AF_INET6
-	else if (addr->sa_family == AF_INET6) {
-		struct sockaddr_in6* addr_in = (struct sockaddr_in6*)addr;
-		addr_in->sin6_port = htons(port);
-
-		/*
-		 * IPv6 Routing Magic:
-		 *
-		 * If the scope of the address is a link-local one, IPv6 requires the
-		 * scope id set to an interface number to allow proper routing. However,
-		 * as the provided sockaddr might contain a wrong scope id, we must find
-		 * a scope id from a suitable interface on this system or routing might
-		 * fail. An IPv6 guru should have another look though...
-		 */
-		addr_in->sin6_scope_id = _sockaddr_in6_scope_id(addr_in);
-
-		addrlen = sizeof(struct sockaddr_in6);
-	}
-#endif
 	else {
 		fprintf(stderr, "ERROR: Unsupported address family");
 		return -1;
diff --git i/tools/iproxy.c w/tools/iproxy.c
index 0a52c67..452ec29 100644
--- i/tools/iproxy.c
+++ w/tools/iproxy.c
@@ -136,15 +136,9 @@ static void *acceptor_thread(void *arg)
 			memcpy(&saddr->sa_data[0], (char*)dev->conn_data + 2, 14);
 		}
 		else if (((char*)dev->conn_data)[1] == 0x1E) { //AF_INET6 (bsd)
-#ifdef AF_INET6
-			saddr->sa_family = AF_INET6;
-			/* copy the address and the host dependent scope id */
-			memcpy(&saddr->sa_data[0], (char*)dev->conn_data + 2, 26);
-#else
 			fprintf(stderr, "ERROR: Got an IPv6 address but this system doesn't support IPv6\n");
 			CDATA_FREE(cdata);
 			return NULL;
-#endif
 		}
 		else {
 			fprintf(stderr, "Unsupported address family 0x%02x\n", ((char*)dev->conn_data)[1]);
@@ -244,11 +238,7 @@ int main(int argc, char **argv)
 	char* source_addr = NULL;
 	uint16_t listen_port[16];
 	uint16_t device_port[16];
-#ifdef AF_INET6
-#define MAX_LISTEN_NUM 32
-#else
 #define MAX_LISTEN_NUM 16
-#endif
 	struct listen_sock {
 		int fd;
 		int index;
@@ -392,21 +382,6 @@ int main(int argc, char **argv)
 			}
 			listen_sock[num_listen].index = i;
 			num_listen++;
-#if defined(AF_INET6)
-			listen_sock[num_listen].fd = socket_create("::1", listen_port[i]);
-			if (listen_sock[num_listen].fd < 0) {
-				int j;
-				fprintf(stderr, "Error creating socket for listen port %u: %s\n", listen_port[i], strerror(errno));
-				free(source_addr);
-				free(device_udid);
-				for (j = num_listen; j >= 0; j--) {
-					socket_close(listen_sock[j].fd);
-				}
-				return -errno;
-			}
-			listen_sock[num_listen].index = i;
-			num_listen++;
-#endif
 		} else {
 			listen_sock[num_listen].fd = socket_create(source_addr, listen_port[i]);
 			if (listen_sock[num_listen].fd < 0) {
